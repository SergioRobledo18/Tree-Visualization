import vcf, random, argparse
from ete3 import Tree, TreeStyle, TextFace, add_face_to_node, NodeStyle
from csv import reader

parser = argparse.ArgumentParser()
parser.add_argument('newickString', help= "Missing the filename where the newick string is being stored")
parser.add_argument('cancerousGenes', help= "Missing the filename where the cancerous genes are being stored")
parser.add_argument('cellStates', help="Missing the filename where the cell states are being stored")
parser.add_argument('unopenedVCF', help="Missing the filename for the annotated vcf file")
args = parser.parse_args()

def secondRecursion(node, parent_state): #root to leaf part of the Fitch Algorithm
    if (parent_state in node.fitch_set):
        node.state=parent_state
    else:
        node.state=random.choice(tuple(node.fitch_set))
    left, right = node.get_children()

    if not left.is_leaf():
        secondRecursion(left, node.state)

    if not right.is_leaf():
        secondRecursion(right, node.state)


def firstRecursion(node,statesOfCells): #leaf to root part of the Fitch Algorithm
    left, right = node.get_children()

    if (left.is_leaf()):
        left.state = statesOfCells.get(left.name)
        left_set = {left.state}
    else:
        firstRecursion(left,statesOfCells)
        left_set= left.fitch_set

    if (right.is_leaf()):
        right.state = statesOfCells.get(right.name)
        right_set = {right.state}
    else:
        firstRecursion(right,statesOfCells)
        right_set = right.fitch_set

    if left_set & right_set: #if true there is an intersection
        node.fitch_set= left_set.intersection(right_set)
    else:
        node.fitch_set= left_set.union(right_set)

def layout_function(node):

    if node.is_leaf(): #adding the node name to leafs
        F=TextFace(node.name, tight_text=True, fsize=15)
        F.rotation= 270
        add_face_to_node(F, node, column=0)

    style1 = NodeStyle()
    style1["fgcolor"] = "blue"
    style1["vt_line_color"] = "blue"
    style1["hz_line_color"] = "blue"
    style1["vt_line_width"] = 2
    style1["hz_line_width"] = 2
    style1["size"] = 5
    style2 = NodeStyle()
    style2["fgcolor"] = "red"
    style2["vt_line_color"] = "red"
    style2["hz_line_color"] = "red"
    style2["vt_line_width"] = 2
    style2["hz_line_width"] = 2
    style2["size"] = 5
    style3 = NodeStyle()
    style3["fgcolor"] = "green"
    style3["vt_line_color"] = "green"
    style3["hz_line_color"] = "green"
    style3["vt_line_width"] = 2
    style3["hz_line_width"] = 2
    style3["size"] = 5

    if node.state=="hypodiploid":
        node.img_style = style1
    elif node.state== "hyperdiploid":
        node.img_style = style2
    else:
        node.img_style = style3

    count=0
    for x in node.geneSet.keys():
        F = TextFace(x, tight_text=True, fsize=14)
        F.rotation = 270
        node.add_face(F, column=count, position="branch-top")
        count+=1

def listFromVCF(filename, purpose): #generates list of cancerous genes from the vcf file
    with open(filename, 'r', encoding='utf-8-sig') as read_obj:

        csv_reader = reader(read_obj)
        if(purpose=="cancerList"):
            setFromVCF = set()
            for row in csv_reader:
                setFromVCF.add(row[0])
        else:
            setFromVCF= {}
            for row in csv_reader:
                setFromVCF[row[0]]=row[1]
    return setFromVCF

def VCFTraversal(t,ID,ANN, cancerousGenes, setOfGenes):
    setOfMutations=[]
    for entry in ANN:
        annotatedList = entry.split("|")  # split the annotation generated by snpEff
        description = annotatedList[1].split("&")  # split the description of the mutation which can be two therefore the need to split

        if ((annotatedList[2] == "MODERATE" or annotatedList[2] == "HIGH") and (annotatedList[3] in cancerousGenes)):
            #node= t & ID
            if (ID == "artificial_root"):
                node = t.get_tree_root()
            else:
                node = t & ID

            #following if statement is incase the gene appears multiple times. Since we want to distiguish the name thus adding stars
            if(annotatedList[3] in setOfGenes and annotatedList[3] not in node.geneSet ):
                totalNumOfOccurences = setOfGenes.get(annotatedList[3])
                star = ""
                for x in range(totalNumOfOccurences):
                    star = "*" + star
                name = annotatedList[3] + star
                if(name not in node.geneSet):
                    totalNumOfOccurences += 1
                    setOfGenes[annotatedList[3]] = totalNumOfOccurences
                    star = ""
                    for x in range(totalNumOfOccurences):
                        star = "*" + star
                    name = annotatedList[3] + star
            else:
                name= annotatedList[3]
                setOfGenes[name]=1

            if(name not in node.geneSet):
                node.geneSet[name]=[]
                node.numberOfGenesPerLocation+=1

                for x in description: #for loop that will traverse the number of mutations according to SnpEff
                    if x not in node.geneSet.get(name):
                        setOfMutations.append(x)
                node.geneSet[name]=setOfMutations[:]

        setOfMutations.clear()

def generateLegend(t,ts):
    legend=[]
    for node in t.traverse():
        for x in node.geneSet:
            mutationInArray = ""
            annotation = ""
            count = 0
            for y in node.geneSet.get(x):
                if(len(node.geneSet.get(x))==1):
                    annotation=x + ": " + (y.replace("_", " "))
                else:
                    count += 1
                    if count != len(node.geneSet.get(x)):
                        mutationInArray = mutationInArray + (y.replace("_", " ")) + ", "  # adding the comma to the string for next mutation
                    else:
                        mutationInArray = mutationInArray + (y.replace("_", " "))  # at the last mutation so you dont need a comma
                        annotation = x + ": " + mutationInArray
            legend.append(annotation)


    legend.sort()  # sort alphabetically
    for entries in legend:
        ts.legend.add_face(TextFace(entries, fsize=15), column=1)
        ts.legend.add_face(TextFace(""), column=0)  # empty text faced used to be able to add the face for the colors

    green = TextFace("")
    green.margin_top = 3
    green.margin_left = 1
    green.margin_right = 1
    green.margin_bottom = 3
    green.background.color = "green"
    ts.legend.add_face(green, column=0)
    ts.legend.add_face(TextFace(" represents diploid cells",fsize=14), column=1)

    red = TextFace("")
    red.margin_top = 3
    red.margin_left = 1
    red.margin_right = 1
    red.margin_bottom = 3
    red.background.color = "red"
    ts.legend.add_face(red, column=0)
    ts.legend.add_face(TextFace(" represents hyperdiploid cells",fsize=14), column=1)

    blue = TextFace("")
    blue.margin_top = 3
    blue.margin_left = 1
    blue.margin_right = 1
    blue.margin_bottom = 3
    blue.background.color = "blue"
    ts.legend.add_face(blue, column=0)
    ts.legend.add_face(TextFace(" represents hypodiploid cells", fsize=14), column=1)

def main():
    t = Tree(args.newickString, format=8)
    setOfGenes= {} #dictionary that keeps track of how many times a gene appears
    cancerousGenes = listFromVCF(args.cancerousGenes, "cancerList")
    statesOfCells = listFromVCF(args.cellStates, "cellStates")
    vcfFile = vcf.Reader(open(args.unopenedVCF, 'r'))  # open the annotated vcf file

    for node in t:  # modify all node distances to 0
        node.dist = 0

    for node in t.traverse(): #create geneSet for each node and a count for the number of genes for that location
        node.geneSet={}
        node.numberOfGenesPerLocation = 0

    for entry in vcfFile:
        if(entry.ID=="artificial_root"):
            node=t.get_tree_root()
        else:
            node = t & entry.ID
        node.dist+=0.03
        VCFTraversal(t, entry.ID, entry.INFO['ANN'], cancerousGenes, setOfGenes)
    ts = TreeStyle()
    ts.rotation = 90
    ts.scale = 5  # changing the number of pixels per branch length unit
    ts.branch_vertical_margin = 10
    ts.scale_length = 30
    ts.show_leaf_name = False
    ts.layout_fn = layout_function
    ts.legend_position = 4

    firstRecursion(t.get_tree_root(), statesOfCells)
    secondRecursion(t.get_tree_root(), "diploid")
    generateLegend(t, ts)
    t.render("tree.png", w=800, h=800, tree_style=ts)
    t.show(tree_style=ts)

if __name__=="__main__":
    main()